import os
import sgtk

import vrFieldAccess
import vrFileIO
import vrMaterialPtr
import vrScenegraph

HookClass = sgtk.get_hook_baseclass()


class SceneOperation(HookClass):
    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of references that are
        to be potentially operated on.
        The return data structure is a list of dictionaries. Each scene reference
        that is returned should be represented by a dictionary with three keys:
        - "node": The name of the 'node' that is to be operated on. Most DCCs have
          a concept of a node, path or some other way to address a particular
          object in the scene.
        - "type": The object type that this is. This is later passed to the
          update method so that it knows how to handle the object.
        - "path": Path on disk to the referenced object.
        Toolkit will scan the list of items, see if any of the objects matches
        any templates and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of date.
        """

        # if many references to the same file exist in the scene, only keep one instance
        scene_refs = []

        for node in vrScenegraph.getAllNodes():
            path = None

            if node.hasAttachment("FileInfo"):
                path = vrFieldAccess.vrFieldAccess(
                    node.getAttachment("FileInfo")
                ).getString("filename")

            if path is not None:
                scene_refs.append(
                    {
                        "node": node.getName(),
                        "type": node.getType(),
                        "path": path,
                        "oldpath": path,
                    }
                )

        scene_refs = [dict(r) for r in {tuple(d.items()) for d in scene_refs}]

        return scene_refs

    def update(self, items):
        """
        Perform replacements given a number of scene items passed from the app.
        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.
        The items parameter is a list of dictionaries on the same form as was
        generated by the scan_scene hook above. The path key now holds
        the that each node should be updated *to* rather than the current path.
        """
        logger = self.parent.engine.logger
        logger.debug("update scene")
        logger.debug(items)

        # Perform update for each item selected.
        for item in items:
            self._update_node(item)

    def _update_node(self, item):
        """
        Perform an update of the selected node, applies transformation and materials
        :param item: item to be updated
        """
        nodes = vrScenegraph.findNodes(item["node"])

        if len(nodes) <= 0:
            return

        path = item["path"]
        name, extension = os.path.splitext(os.path.basename(path))

        materials_dict = self._obtain_materials()

        # load the geometry for the first node but after that, try to clone this node to avoid importing the file
        # many time
        new_node = vrFileIO.loadGeometry(path)
        if name == new_node.getName():
            self._apply_transformations(nodes[0], new_node, materials_dict)
        nodes[0].getParent().addChild(new_node)

        # now, clone the new node as many time as we have remaining node instances
        for n in nodes[1:]:
            new_n = new_node.clone()
            if name == new_n.getName():
                self._apply_transformations(n, new_n, materials_dict)
            n.getParent().addChild(new_n)

        # delete the nodes once everything has been created to avoid parent/child issue
        vrScenegraph.deleteNodes(nodes, True)

    def _obtain_materials(self):
        """
        Obtain a materials list with respective nodes
        :return: list of materials
        """
        materials = []

        for material in vrMaterialPtr.getAllMaterials():
            name = material.getName()

            if name == "DefaultShader":
                continue

            nodes = [node.getName() for node in material.getNodes()]

            materials.append({"name": name, "material": material, "nodes": nodes})

        return materials

    def _apply_transformations(self, old_node, new_node, materials):
        """
        Recursive to apply transformations and materials to node and childs
        :param old_node: previous node with transformations and materials
        :param new_node: new node to apply transformations and materials
        :param materials: list of materials
        """
        if old_node.getName() == "Surface":
            return

        vrScenegraph.copyTransformation(old_node, new_node)

        self._apply_materials(old_node, new_node, materials)

        old_node_child = old_node.getChild(0)
        old_node_child_name = old_node_child.getName()

        for i in range(0, new_node.getNChildren()):
            new_node_child = new_node.getChild(i)
            new_node_child_name = new_node_child.getName()

            if old_node_child_name == new_node_child_name:
                self._apply_transformations(old_node_child, new_node_child, materials)
                break

    def _apply_materials(self, old_node, new_node, materials):
        """
        Apply materials for the new node based on old node
        :param old_node: old node with materials
        :param new_node: new node to apply materials
        :param materials: materials list
        """
        materials_to_apply = []

        for material in materials:
            if old_node.getName() in material.get("nodes"):
                materials_to_apply.append(material.get("material"))

        vrScenegraph.applyMaterial([new_node], materials_to_apply, False, False)
