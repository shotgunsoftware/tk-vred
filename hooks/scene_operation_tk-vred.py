import sgtk
import vrFileIO
import vrController
import vrScript
import vrScenegraph
from sgtk import TankError
import vrFieldAccess

HookClass = sgtk.get_hook_baseclass()
class SceneOperation(HookClass):
    def execute(self, operation, file_path=None, context=None, parent_action=None, file_version=None, read_only=None, **kwargs):
        if operation == "current_path":
            # Get the current file path.
            current_path = self.parent.engine.get_current_file()
            if current_path == None:
                return "" #it's a new file
            else:
                return current_path
        else:
            if operation == "open":
                self.parent.engine.log_info("Scene Operation, Open file: "+file_path)
                self.parent.engine.reset_scene()
                self.parent.engine.load_file(file_path)
            elif operation == "save":
                # If file path not specified save in place.
                if file_path == None:
                    file_path = self.parent.engine.get_current_file()
                self.parent.engine.log_info("Scene Operation, Save file: "+file_path)
                self.parent.engine.save_current_file(file_path)
            elif operation == "save_as":
                self.parent.engine.log_info("Scene Operation, Save_as file: "+file_path)
                self.parent.engine.save_current_file(file_path)
            elif operation == "reset":
                self.parent.engine.log_info("Scene Operation, Reset Scene")
                # Reset the Scene in VRED
                self.parent.engine.reset_scene()
               
            sgtk.platform.current_engine().rebuild_shotgun_menu()
            return True

    def scan_scene(self):
        """
        The scan scene method is executed once at startup and its purpose is
        to analyze the current scene and return a list of references that are
        to be potentially operated on.
        The return data structure is a list of dictionaries. Each scene reference
        that is returned should be represented by a dictionary with three keys:
        - "node": The name of the 'node' that is to be operated on. Most DCCs have
          a concept of a node, path or some other way to address a particular
          object in the scene.
        - "type": The object type that this is. This is later passed to the
          update method so that it knows how to handle the object.
        - "path": Path on disk to the referenced object.
        Toolkit will scan the list of items, see if any of the objects matches
        any templates and try to determine if there is a more recent version
        available. Any such versions are then displayed in the UI as out of date.
        """
        return_ref_list = []
        _nodeList = vrScenegraph.getAllNodes()
        for _node in _nodeList:
            _filePath = None
            if _node.hasAttachment("FileInfo"):
                _att = _node.getAttachment("FileInfo")
                _filePath = vrFieldAccess.vrFieldAccess(_att).getString("filename")
            if _filePath is not None:
                return_ref_list.append({
                        "node": _node.getName(),
                        "type": _node.getType(),
                        "path": _filePath,
                        "oldpath": _filePath
                    })
        return return_ref_list
    
    def update(self, items):
        """
        Perform replacements given a number of scene items passed from the app.
        Once a selection has been performed in the main UI and the user clicks
        the update button, this method is called.
        The items parameter is a list of dictionaries on the same form as was
        generated by the scan_scene hook above. The path key now holds
        the that each node should be updated *to* rather than the current path.
        """
        app = self.parent.engine
        app.log_info("update scene")
        app.log_info(items)
        _nodeList = vrScenegraph.getAllNodes()
        
        # Perform update for each item selected.
        for item in items:
            for _node in _nodeList:
                _filePath = None
                if _node.hasAttachment("FileInfo"):
                    _att = _node.getAttachment("FileInfo")
                    _filePath = vrFieldAccess.vrFieldAccess(_att).getString("filename")
                if _filePath is not None and item["node"] == _node.getName():
                    # Delete the node 
                    if vrScenegraph.deleteNode(_node,True):
                        # Load the new node.
                        self.parent.engine.load_file(item["path"])
        